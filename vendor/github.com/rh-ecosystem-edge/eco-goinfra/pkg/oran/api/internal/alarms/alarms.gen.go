// Package alarms provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package alarms

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/rh-ecosystem-edge/eco-goinfra/pkg/oran/api/internal/common"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for AlarmEventNotificationNotificationEventType.
const (
	AlarmEventNotificationNotificationEventTypeACKNOWLEDGE AlarmEventNotificationNotificationEventType = 3
	AlarmEventNotificationNotificationEventTypeCHANGE      AlarmEventNotificationNotificationEventType = 1
	AlarmEventNotificationNotificationEventTypeCLEAR       AlarmEventNotificationNotificationEventType = 2
	AlarmEventNotificationNotificationEventTypeNEW         AlarmEventNotificationNotificationEventType = 0
)

// Defines values for AlarmSubscriptionInfoFilter.
const (
	AlarmSubscriptionInfoFilterACKNOWLEDGE AlarmSubscriptionInfoFilter = "ACKNOWLEDGE"
	AlarmSubscriptionInfoFilterCHANGE      AlarmSubscriptionInfoFilter = "CHANGE"
	AlarmSubscriptionInfoFilterCLEAR       AlarmSubscriptionInfoFilter = "CLEAR"
	AlarmSubscriptionInfoFilterNEW         AlarmSubscriptionInfoFilter = "NEW"
)

// Defines values for AlertmanagerNotificationStatus.
const (
	Firing   AlertmanagerNotificationStatus = "firing"
	Resolved AlertmanagerNotificationStatus = "resolved"
)

// Defines values for PerceivedSeverity.
const (
	CLEARED       PerceivedSeverity = 5
	CRITICAL      PerceivedSeverity = 0
	INDETERMINATE PerceivedSeverity = 4
	MAJOR         PerceivedSeverity = 1
	MINOR         PerceivedSeverity = 2
	WARNING       PerceivedSeverity = 3
)

// AlarmEventNotification Alarm Event Notification sent to subscribers
type AlarmEventNotification struct {
	// AlarmAcknowledgeTime Date/Time stamp value when any value of the AlarmEventRecord has been modified.
	AlarmAcknowledgeTime *time.Time `json:"alarmAcknowledgeTime,omitempty"`

	// AlarmAcknowledged Boolean value indicating of a management system has acknowledged the alarm.
	AlarmAcknowledged bool `json:"alarmAcknowledged"`

	// AlarmChangedTime Date/Time stamp value when any value of the AlarmEventRecord has been modified.
	AlarmChangedTime time.Time `json:"alarmChangedTime"`

	// AlarmDefinitionID A reference to the Alarm Definition record in the Alarm Dictionary associated with the referenced ResourceType.
	AlarmDefinitionID openapi_types.UUID `json:"alarmDefinitionID"`

	// AlarmEventRecordId The URL to the AlarmEventRecord object.
	AlarmEventRecordId openapi_types.UUID `json:"alarmEventRecordId"`

	// AlarmRaisedTime Date/Time stamp value when the AlarmEventRecord has been created.
	AlarmRaisedTime time.Time `json:"alarmRaisedTime"`

	// ConsumerSubscriptionId The value provided by the consumer in the subscription.
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// Extensions These are unspecified (not standardized) properties (keys) which are tailored by the vendor or
	// operator to extend the information provided about the O-Cloud Alarm.
	Extensions map[string]string `json:"extensions"`

	// GlobalCloudID The global cloud identifier assigned by the SMO.e
	GlobalCloudID openapi_types.UUID `json:"globalCloudID"`

	// NotificationEventType Notification event type values
	NotificationEventType AlarmEventNotificationNotificationEventType `json:"notificationEventType"`

	// ObjectRef The URL to the AlarmEventRecord object.
	ObjectRef *string `json:"objectRef,omitempty"`

	// PerceivedSeverity This is an enumerated set of values which identify the perceived severity of the alarm.
	PerceivedSeverity PerceivedSeverity `json:"perceivedSeverity"`

	// ProbableCauseID A reference to the ProbableCause of the Alarm.
	ProbableCauseID openapi_types.UUID `json:"probableCauseID"`

	// ResourceID A reference to the resource instance which caused the alarm.
	ResourceID openapi_types.UUID `json:"resourceID"`

	// ResourceTypeID A reference to the type of resource which caused the alarm.
	ResourceTypeID openapi_types.UUID `json:"resourceTypeID"`
}

// AlarmEventNotificationNotificationEventType Notification event type values
type AlarmEventNotificationNotificationEventType int

// AlarmEventRecord defines model for AlarmEventRecord.
type AlarmEventRecord struct {
	// AlarmAcknowledged When a system acknowledges an alarm, it is then set to TRUE.
	AlarmAcknowledged bool `json:"alarmAcknowledged"`

	// AlarmAcknowledgedTime This field is populated with a Date/Time stamp value when the alarm condition is acknowledged.
	AlarmAcknowledgedTime *time.Time `json:"alarmAcknowledgedTime,omitempty"`

	// AlarmChangedTime This field is populated with a Date/Time stamp value when any value
	// of the AlarmEventRecord is modified.
	AlarmChangedTime *time.Time `json:"alarmChangedTime,omitempty"`

	// AlarmClearedTime This field is populated with a Date/Time stamp value when the alarm condition is cleared.
	AlarmClearedTime *time.Time `json:"alarmClearedTime,omitempty"`

	// AlarmDefinitionID A reference to the Alarm Definition record in the Alarm Dictionary associated with the referenced Resource Type.
	AlarmDefinitionID openapi_types.UUID `json:"alarmDefinitionID"`

	// AlarmEventRecordId Identifier of an entry in the AlarmEventRecord.
	// Locally unique within the scope of an O-Cloud instance.
	AlarmEventRecordId openapi_types.UUID `json:"alarmEventRecordId"`

	// AlarmRaisedTime This field is populated with a Date/Time stamp value when the AlarmEventRecord is created.
	AlarmRaisedTime time.Time `json:"alarmRaisedTime"`

	// Extensions These are unspecified (not standardized) properties (keys) which are tailored by the vendor or
	// operator to extend the information provided about the O-Cloud Alarm.
	Extensions map[string]string `json:"extensions"`

	// PerceivedSeverity This is an enumerated set of values which identify the perceived severity of the alarm.
	PerceivedSeverity PerceivedSeverity `json:"perceivedSeverity"`

	// ProbableCauseID A reference to the ProbableCause of the Alarm.
	ProbableCauseID openapi_types.UUID `json:"probableCauseID"`

	// ResourceID A reference to the resource which caused the alarm.
	ResourceID openapi_types.UUID `json:"resourceID"`

	// ResourceTypeID A reference to the type of resource which caused the alarm.
	ResourceTypeID openapi_types.UUID `json:"resourceTypeID"`
}

// AlarmEventRecordModifications defines model for AlarmEventRecordModifications.
type AlarmEventRecordModifications struct {
	// AlarmAcknowledged Acknowledge an alarm.
	AlarmAcknowledged *bool `json:"alarmAcknowledged,omitempty"`

	// PerceivedSeverity This is an enumerated set of values which identify the perceived severity of the alarm.
	PerceivedSeverity *PerceivedSeverity `json:"perceivedSeverity,omitempty"`
}

// AlarmServiceConfiguration defines model for AlarmServiceConfiguration.
type AlarmServiceConfiguration struct {
	// Extensions List of metadata key-value pairs used to associate meaningful metadata to the related alarm service
	Extensions *map[string]string `json:"extensions,omitempty"`

	// RetentionPeriod Number of days for alarm history to be retained.
	// This value has cannot be set lower than 1 (day).
	RetentionPeriod int `json:"retentionPeriod"`
}

// AlarmSubscriptionInfo defines model for AlarmSubscriptionInfo.
type AlarmSubscriptionInfo struct {
	// AlarmSubscriptionId Identifier for the Alarm Subscription. This identifier is allocated by the O-Cloud.
	AlarmSubscriptionId *openapi_types.UUID `json:"alarmSubscriptionId,omitempty"`

	// Callback The fully qualified URI to a consumer procedure which can process a Post of the AlarmEventNotification.
	Callback string `json:"callback"`

	// ConsumerSubscriptionId Identifier for the consumer of events sent due to the Subscription.
	ConsumerSubscriptionId *openapi_types.UUID `json:"consumerSubscriptionId,omitempty"`

	// Filter Criteria for events which do not need to be reported or will be filtered by the subscription
	// notification service. Therefore, if a filter is not provided then all events are reported.
	// It can be filtered by criteria based on the type of notification of fields of the
	// AlarmEventRecord.
	Filter *AlarmSubscriptionInfoFilter `json:"filter,omitempty"`
}

// AlarmSubscriptionInfoFilter Criteria for events which do not need to be reported or will be filtered by the subscription
// notification service. Therefore, if a filter is not provided then all events are reported.
// It can be filtered by criteria based on the type of notification of fields of the
// AlarmEventRecord.
type AlarmSubscriptionInfoFilter string

// Alert defines model for Alert.
type Alert struct {
	Annotations *map[string]string `json:"annotations,omitempty"`
	EndsAt      *time.Time         `json:"endsAt,omitempty"`

	// Fingerprint Fingerprint to identify the alert
	Fingerprint *string `json:"fingerprint,omitempty"`

	// GeneratorURL Identifies the entity that caused the alert
	GeneratorURL *string            `json:"generatorURL,omitempty"`
	Labels       *map[string]string `json:"labels,omitempty"`
	StartsAt     *time.Time         `json:"startsAt,omitempty"`

	// Status Alertmanager notification status
	Status *AlertmanagerNotificationStatus `json:"status,omitempty"`
}

// AlertmanagerNotification Alertmanager notification payload as described here https://prometheus.io/docs/alerting/latest/configuration/#webhook_config
type AlertmanagerNotification struct {
	Alerts            []Alert            `json:"alerts"`
	CommonAnnotations *map[string]string `json:"commonAnnotations,omitempty"`
	CommonLabels      *map[string]string `json:"commonLabels,omitempty"`

	// ExternalURL Backlink to the Alertmanager
	ExternalURL *string `json:"externalURL,omitempty"`

	// GroupKey Key identifying the group of alerts (e.g. to deduplicate)
	GroupKey    string             `json:"groupKey"`
	GroupLabels *map[string]string `json:"groupLabels,omitempty"`
	Receiver    string             `json:"receiver"`

	// Status Alertmanager notification status
	Status AlertmanagerNotificationStatus `json:"status"`

	// Subscriber Optional subscriber information, if a subscriber is found
	Subscriber *struct {
		// CallbackUrl URL to call for notifying the subscriber
		CallbackUrl *string `json:"callbackUrl,omitempty"`
	} `json:"subscriber,omitempty"`

	// TruncatedAlerts How many alerts have been truncated due to "max_alerts"
	TruncatedAlerts *int   `json:"truncatedAlerts,omitempty"`
	Version         string `json:"version"`
}

// AlertmanagerNotificationStatus Alertmanager notification status
type AlertmanagerNotificationStatus string

// HardwareAlert Placeholder for hardware alert schema
type HardwareAlert = map[string]interface{}

// PerceivedSeverity This is an enumerated set of values which identify the perceived severity of the alarm.
type PerceivedSeverity int

// ProbableCause defines model for ProbableCause.
type ProbableCause struct {
	// Description Any additional information beyond the name to describe the probableCause derived from corresponding AlarmDefinition.
	Description string `json:"description"`

	// Name Human readable text of the probable cause derived from corresponding AlarmDefinition.
	Name string `json:"name"`

	// ProbableCauseId Identifier of the ProbableCause.
	ProbableCauseId openapi_types.UUID `json:"probableCauseId"`
}

// GetSubscriptionsParams defines parameters for GetSubscriptions.
type GetSubscriptionsParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetAlarmsParams defines parameters for GetAlarms.
type GetAlarmsParams struct {
	// AllFields This URI query parameter requests that all complex attributes are included in the response.
	//
	// ```
	// all_fields
	// ```
	AllFields *externalRef0.AllFields `form:"all_fields,omitempty" json:"all_fields,omitempty"`

	// ExcludeFields Comma separated list of field references to exclude from the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to exclude the `country` subfield of the `extensions` field:
	//
	// ```
	// exclude_fields=extensions/country
	// ```
	//
	// When this parameter isn't used no field will be excluded.
	//
	// Fields in this list will be excluded even if they are explicitly included using the
	// `fields` parameter.
	ExcludeFields *externalRef0.ExcludeFields `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`

	// Fields Comma separated list of field references to include in the result.
	//
	// Each field reference is a field name, or a sequence of field names separated by slashes. For
	// example, to get the `name` field and the `country` subfield of the `extensions` field:
	//
	// ```
	// fields=name,extensions/country
	// ```
	//
	// When this parameter isn't used all the fields will be returned.
	Fields *externalRef0.Fields `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter Search criteria.
	//
	// Contains one or more search criteria, separated by semicolons. Each search criteria is a
	// tuple containing an operator, a field reference and one or more values. The operator can
	// be any of the following strings:
	//
	// | Operator | Meaning                                                     |
	// |----------|-------------------------------------------------------------|
	// | `cont`   | Matches if the field contains the value                     |
	// | `eq`     | Matches if the field is equal to the value                  |
	// | `gt`     | Matches if the field is greater than the value              |
	// | `gte`    | Matches if the field is greater than or equal to the value  |
	// | `in`     | Matches if the field is one of the values                   |
	// | `lt`     | Matches if the field is less than the value                 |
	// | `lte`    | Matches if the field is less than or equal to the the value |
	// | `ncont`  | Matches if the field does not contain the value             |
	// | `neq`    | Matches if the field is not equal to the value              |
	// | `nin`    | Matches if the field is not one of the values               |
	//
	// The field reference is the name of one of the fields of the object, or a sequence of
	// name of fields separated by slashes. For example, to use the `country` sub-field inside
	// the `extensions` field:
	//
	// ```
	// filter=(eq,extensions/country,EQ)
	// ```
	//
	// The values are the arguments of the operator. For example, the `eq` operator compares
	// checks if the value of the field is equal to the value.
	//
	// The `in` and `nin` operators support multiple values. For example, to check if the `country`
	// sub-field inside the `extensions` field is either `ES` or `US:
	//
	// ```
	// filter=(in,extensions/country,ES,US)
	// ```
	//
	// When values contain commas, slashes or spaces they need to be surrounded by single quotes.
	// For example, to check if the `name` field is the string `my cluster`:
	//
	// ```
	// filter=(eq,name,'my cluster')
	// ```
	//
	// When multiple criteria separated by semicolons are used, all of them must match for the
	// complete condition to match. For example, the following will check if the `name` is
	// `my cluster` *and* the `country` extension is `ES`:
	//
	// ```
	// filter=(eq,name,'my cluster');(eq,extensions/country,ES)
	// ```
	//
	// When this parameter isn't used all the results will be returned.
	Filter *externalRef0.Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody defines body for PatchAlarmServiceConfiguration for application/merge-patch+json ContentType.
type PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody = AlarmServiceConfiguration

// UpdateAlarmServiceConfigurationJSONRequestBody defines body for UpdateAlarmServiceConfiguration for application/json ContentType.
type UpdateAlarmServiceConfigurationJSONRequestBody = AlarmServiceConfiguration

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = AlarmSubscriptionInfo

// PatchAlarmApplicationMergePatchPlusJSONRequestBody defines body for PatchAlarm for application/merge-patch+json ContentType.
type PatchAlarmApplicationMergePatchPlusJSONRequestBody = AlarmEventRecordModifications

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllVersions request
	GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceConfiguration request
	GetServiceConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAlarmServiceConfigurationWithBody request with any body
	PatchAlarmServiceConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAlarmServiceConfigurationWithApplicationMergePatchPlusJSONBody(ctx context.Context, body PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAlarmServiceConfigurationWithBody request with any body
	UpdateAlarmServiceConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAlarmServiceConfiguration(ctx context.Context, body UpdateAlarmServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscriptions request
	GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSubscription request
	GetSubscription(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarms request
	GetAlarms(ctx context.Context, params *GetAlarmsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlarm request
	GetAlarm(ctx context.Context, alarmEventRecordId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAlarmWithBody request with any body
	PatchAlarmWithBody(ctx context.Context, alarmEventRecordId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchAlarmWithApplicationMergePatchPlusJSONBody(ctx context.Context, alarmEventRecordId openapi_types.UUID, body PatchAlarmApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMinorVersions request
	GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAlarmServiceConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAlarmServiceConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAlarmServiceConfigurationWithApplicationMergePatchPlusJSONBody(ctx context.Context, body PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAlarmServiceConfigurationRequestWithApplicationMergePatchPlusJSONBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlarmServiceConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAlarmServiceConfigurationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlarmServiceConfiguration(ctx context.Context, body UpdateAlarmServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAlarmServiceConfigurationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscriptions(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSubscription(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSubscriptionRequest(c.Server, alarmSubscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSubscription(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSubscriptionRequest(c.Server, alarmSubscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarms(ctx context.Context, params *GetAlarmsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlarm(ctx context.Context, alarmEventRecordId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlarmRequest(c.Server, alarmEventRecordId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAlarmWithBody(ctx context.Context, alarmEventRecordId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAlarmRequestWithBody(c.Server, alarmEventRecordId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchAlarmWithApplicationMergePatchPlusJSONBody(ctx context.Context, alarmEventRecordId openapi_types.UUID, body PatchAlarmApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAlarmRequestWithApplicationMergePatchPlusJSONBody(c.Server, alarmEventRecordId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMinorVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMinorVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllVersionsRequest generates requests for GetAllVersions
func NewGetAllVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceConfigurationRequest generates requests for GetServiceConfiguration
func NewGetServiceConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmServiceConfiguration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAlarmServiceConfigurationRequestWithApplicationMergePatchPlusJSONBody calls the generic PatchAlarmServiceConfiguration builder with application/merge-patch+json body
func NewPatchAlarmServiceConfigurationRequestWithApplicationMergePatchPlusJSONBody(server string, body PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAlarmServiceConfigurationRequestWithBody(server, "application/merge-patch+json", bodyReader)
}

// NewPatchAlarmServiceConfigurationRequestWithBody generates requests for PatchAlarmServiceConfiguration with any type of body
func NewPatchAlarmServiceConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmServiceConfiguration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAlarmServiceConfigurationRequest calls the generic UpdateAlarmServiceConfiguration builder with application/json body
func NewUpdateAlarmServiceConfigurationRequest(server string, body UpdateAlarmServiceConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAlarmServiceConfigurationRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateAlarmServiceConfigurationRequestWithBody generates requests for UpdateAlarmServiceConfiguration with any type of body
func NewUpdateAlarmServiceConfigurationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmServiceConfiguration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSubscriptionsRequest generates requests for GetSubscriptions
func NewGetSubscriptionsRequest(server string, params *GetSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmSubscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmSubscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSubscriptionRequest generates requests for DeleteSubscription
func NewDeleteSubscriptionRequest(server string, alarmSubscriptionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmSubscriptionId", runtime.ParamLocationPath, alarmSubscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmSubscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSubscriptionRequest generates requests for GetSubscription
func NewGetSubscriptionRequest(server string, alarmSubscriptionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmSubscriptionId", runtime.ParamLocationPath, alarmSubscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarmSubscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmsRequest generates requests for GetAlarms
func NewGetAlarmsRequest(server string, params *GetAlarmsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_fields", runtime.ParamLocationQuery, *params.ExcludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlarmRequest generates requests for GetAlarm
func NewGetAlarmRequest(server string, alarmEventRecordId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmEventRecordId", runtime.ParamLocationPath, alarmEventRecordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAlarmRequestWithApplicationMergePatchPlusJSONBody calls the generic PatchAlarm builder with application/merge-patch+json body
func NewPatchAlarmRequestWithApplicationMergePatchPlusJSONBody(server string, alarmEventRecordId openapi_types.UUID, body PatchAlarmApplicationMergePatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAlarmRequestWithBody(server, alarmEventRecordId, "application/merge-patch+json", bodyReader)
}

// NewPatchAlarmRequestWithBody generates requests for PatchAlarm with any type of body
func NewPatchAlarmRequestWithBody(server string, alarmEventRecordId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alarmEventRecordId", runtime.ParamLocationPath, alarmEventRecordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/alarms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMinorVersionsRequest generates requests for GetMinorVersions
func NewGetMinorVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/o2ims-infrastructureMonitoring/v1/api_versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllVersionsWithResponse request
	GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error)

	// GetServiceConfigurationWithResponse request
	GetServiceConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceConfigurationResponse, error)

	// PatchAlarmServiceConfigurationWithBodyWithResponse request with any body
	PatchAlarmServiceConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAlarmServiceConfigurationResponse, error)

	PatchAlarmServiceConfigurationWithApplicationMergePatchPlusJSONBodyWithResponse(ctx context.Context, body PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAlarmServiceConfigurationResponse, error)

	// UpdateAlarmServiceConfigurationWithBodyWithResponse request with any body
	UpdateAlarmServiceConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAlarmServiceConfigurationResponse, error)

	UpdateAlarmServiceConfigurationWithResponse(ctx context.Context, body UpdateAlarmServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAlarmServiceConfigurationResponse, error)

	// GetSubscriptionsWithResponse request
	GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscriptionWithResponse request
	DeleteSubscriptionWithResponse(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// GetSubscriptionWithResponse request
	GetSubscriptionWithResponse(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error)

	// GetAlarmsWithResponse request
	GetAlarmsWithResponse(ctx context.Context, params *GetAlarmsParams, reqEditors ...RequestEditorFn) (*GetAlarmsResponse, error)

	// GetAlarmWithResponse request
	GetAlarmWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAlarmResponse, error)

	// PatchAlarmWithBodyWithResponse request with any body
	PatchAlarmWithBodyWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAlarmResponse, error)

	PatchAlarmWithApplicationMergePatchPlusJSONBodyWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, body PatchAlarmApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAlarmResponse, error)

	// GetMinorVersionsWithResponse request
	GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error)
}

type GetAllVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAllVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceConfigurationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmServiceConfiguration
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAlarmServiceConfigurationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmServiceConfiguration
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON412 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r PatchAlarmServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAlarmServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAlarmServiceConfigurationResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmServiceConfiguration
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON412 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r UpdateAlarmServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAlarmServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]AlarmSubscriptionInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *AlarmSubscriptionInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON409 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmSubscriptionInfo
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]AlarmEventRecord
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlarmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmEventRecord
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetAlarmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlarmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAlarmResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AlarmEventRecordModifications
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON404 *externalRef0.ProblemDetails
	ApplicationProblemJSON409 *externalRef0.ProblemDetails
	ApplicationProblemJSON412 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r PatchAlarmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAlarmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMinorVersionsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *externalRef0.APIVersions
	ApplicationProblemJSON400 *externalRef0.ProblemDetails
	ApplicationProblemJSON401 *externalRef0.ProblemDetails
	ApplicationProblemJSON403 *externalRef0.ProblemDetails
	ApplicationProblemJSON500 *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r GetMinorVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMinorVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllVersionsWithResponse request returning *GetAllVersionsResponse
func (c *ClientWithResponses) GetAllVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVersionsResponse, error) {
	rsp, err := c.GetAllVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVersionsResponse(rsp)
}

// GetServiceConfigurationWithResponse request returning *GetServiceConfigurationResponse
func (c *ClientWithResponses) GetServiceConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServiceConfigurationResponse, error) {
	rsp, err := c.GetServiceConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceConfigurationResponse(rsp)
}

// PatchAlarmServiceConfigurationWithBodyWithResponse request with arbitrary body returning *PatchAlarmServiceConfigurationResponse
func (c *ClientWithResponses) PatchAlarmServiceConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAlarmServiceConfigurationResponse, error) {
	rsp, err := c.PatchAlarmServiceConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAlarmServiceConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PatchAlarmServiceConfigurationWithApplicationMergePatchPlusJSONBodyWithResponse(ctx context.Context, body PatchAlarmServiceConfigurationApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAlarmServiceConfigurationResponse, error) {
	rsp, err := c.PatchAlarmServiceConfigurationWithApplicationMergePatchPlusJSONBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAlarmServiceConfigurationResponse(rsp)
}

// UpdateAlarmServiceConfigurationWithBodyWithResponse request with arbitrary body returning *UpdateAlarmServiceConfigurationResponse
func (c *ClientWithResponses) UpdateAlarmServiceConfigurationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAlarmServiceConfigurationResponse, error) {
	rsp, err := c.UpdateAlarmServiceConfigurationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAlarmServiceConfigurationResponse(rsp)
}

func (c *ClientWithResponses) UpdateAlarmServiceConfigurationWithResponse(ctx context.Context, body UpdateAlarmServiceConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAlarmServiceConfigurationResponse, error) {
	rsp, err := c.UpdateAlarmServiceConfiguration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAlarmServiceConfigurationResponse(rsp)
}

// GetSubscriptionsWithResponse request returning *GetSubscriptionsResponse
func (c *ClientWithResponses) GetSubscriptionsWithResponse(ctx context.Context, params *GetSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetSubscriptionsResponse, error) {
	rsp, err := c.GetSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionsResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// DeleteSubscriptionWithResponse request returning *DeleteSubscriptionResponse
func (c *ClientWithResponses) DeleteSubscriptionWithResponse(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	rsp, err := c.DeleteSubscription(ctx, alarmSubscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSubscriptionResponse(rsp)
}

// GetSubscriptionWithResponse request returning *GetSubscriptionResponse
func (c *ClientWithResponses) GetSubscriptionWithResponse(ctx context.Context, alarmSubscriptionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSubscriptionResponse, error) {
	rsp, err := c.GetSubscription(ctx, alarmSubscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSubscriptionResponse(rsp)
}

// GetAlarmsWithResponse request returning *GetAlarmsResponse
func (c *ClientWithResponses) GetAlarmsWithResponse(ctx context.Context, params *GetAlarmsParams, reqEditors ...RequestEditorFn) (*GetAlarmsResponse, error) {
	rsp, err := c.GetAlarms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmsResponse(rsp)
}

// GetAlarmWithResponse request returning *GetAlarmResponse
func (c *ClientWithResponses) GetAlarmWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAlarmResponse, error) {
	rsp, err := c.GetAlarm(ctx, alarmEventRecordId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlarmResponse(rsp)
}

// PatchAlarmWithBodyWithResponse request with arbitrary body returning *PatchAlarmResponse
func (c *ClientWithResponses) PatchAlarmWithBodyWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAlarmResponse, error) {
	rsp, err := c.PatchAlarmWithBody(ctx, alarmEventRecordId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAlarmResponse(rsp)
}

func (c *ClientWithResponses) PatchAlarmWithApplicationMergePatchPlusJSONBodyWithResponse(ctx context.Context, alarmEventRecordId openapi_types.UUID, body PatchAlarmApplicationMergePatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAlarmResponse, error) {
	rsp, err := c.PatchAlarmWithApplicationMergePatchPlusJSONBody(ctx, alarmEventRecordId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAlarmResponse(rsp)
}

// GetMinorVersionsWithResponse request returning *GetMinorVersionsResponse
func (c *ClientWithResponses) GetMinorVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMinorVersionsResponse, error) {
	rsp, err := c.GetMinorVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMinorVersionsResponse(rsp)
}

// ParseGetAllVersionsResponse parses an HTTP response from a GetAllVersionsWithResponse call
func ParseGetAllVersionsResponse(rsp *http.Response) (*GetAllVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceConfigurationResponse parses an HTTP response from a GetServiceConfigurationWithResponse call
func ParseGetServiceConfigurationResponse(rsp *http.Response) (*GetServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmServiceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchAlarmServiceConfigurationResponse parses an HTTP response from a PatchAlarmServiceConfigurationWithResponse call
func ParsePatchAlarmServiceConfigurationResponse(rsp *http.Response) (*PatchAlarmServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAlarmServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmServiceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAlarmServiceConfigurationResponse parses an HTTP response from a UpdateAlarmServiceConfigurationWithResponse call
func ParseUpdateAlarmServiceConfigurationResponse(rsp *http.Response) (*UpdateAlarmServiceConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAlarmServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmServiceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionsResponse parses an HTTP response from a GetSubscriptionsWithResponse call
func ParseGetSubscriptionsResponse(rsp *http.Response) (*GetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AlarmSubscriptionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AlarmSubscriptionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSubscriptionResponse parses an HTTP response from a DeleteSubscriptionWithResponse call
func ParseDeleteSubscriptionResponse(rsp *http.Response) (*DeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetSubscriptionResponse parses an HTTP response from a GetSubscriptionWithResponse call
func ParseGetSubscriptionResponse(rsp *http.Response) (*GetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmSubscriptionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmsResponse parses an HTTP response from a GetAlarmsWithResponse call
func ParseGetAlarmsResponse(rsp *http.Response) (*GetAlarmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AlarmEventRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetAlarmResponse parses an HTTP response from a GetAlarmWithResponse call
func ParseGetAlarmResponse(rsp *http.Response) (*GetAlarmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlarmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmEventRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParsePatchAlarmResponse parses an HTTP response from a PatchAlarmWithResponse call
func ParsePatchAlarmResponse(rsp *http.Response) (*PatchAlarmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAlarmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlarmEventRecordModifications
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetMinorVersionsResponse parses an HTTP response from a GetMinorVersionsWithResponse call
func ParseGetMinorVersionsResponse(rsp *http.Response) (*GetMinorVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMinorVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.APIVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationProblemJSON500 = &dest

	}

	return response, nil
}
